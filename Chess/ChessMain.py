"""
This is the main file. It is responsible for handling user input and
displaying the current Game State
"""

import pygame as pg
import ChessEngine, ChessAI
# ChessMain.py

import board
import pieces
import ai
from move import Move


game_board = board.Board.new()

print(game_board.to_string())

user_move = Move(0, 1, 0, 3)
game_board.perform_move(user_move)

print(game_board.to_string())

ai_move = ai.AI.get_ai_move(game_board, [])
game_board.perform_move(ai_move)

print(game_board.to_string())

screenWidth = screenHeight = 512  # Setting up the size of the screen
moveHistoryPanelWidth = 350
moveHistoryPanelHeight = screenHeight
boardSize = 8  # Chess Boards are 8x8
squareSize = screenHeight // boardSize  # Creating the dimensions of each square as fraction of the screen size
maxFrameRate = 20  # For animations
Images = {}  # only want to load images once
animate = False  # Should only animate when a move is being made not when it is being undone

'''
I am going to load each image once in the main file.
'''

def load_piece_images():
    pieces = ['wp', 'wR', 'wN', 'wB', 'wK', 'wQ', 'bp', 'bR', 'bN','bB', 'bK', 'bQ']
    for piece in pieces:
        Images[piece] = pg.transform.scale(pg.image.load("images/" + piece + ".png"), (squareSize, squareSize))

# Now I can access any image by just typing Images['pieceName']

'''
This function is responsible for drawing the board and
initialising pygame
It will be in charge of displaying the screen, controlling the
frame rate,
and loading images onto the screen.
'''

def main():
    pg.init()
    screen = pg.display.set_mode((screenWidth + moveHistoryPanelWidth, screenHeight))
    clock = pg.time.Clock()  # controls the frame rate
    screen.fill(pg.Color('White'))
    moveLogFont = pg.font.SysFont('Arial', 18)  # Changed from Font to SysFont
    gs = ChessEngine.GameState()
    load_piece_images()  # will only load the images once

    # Game state variables
    isGameRunning = True
    sqSelected = ()  # use of a tuple (row,col) here instead of having to reference the x and y coordinates
    playerMoveClicks = []  # Keeps tracks of the player clicks consisting of two tuples [(3,2), (5,5)]
    legalMoves = gs.get_valid_moves()
    print(legalMoves)
    isMoveMade = False  # A new set of valid moves will only be generated if a valid move is made in the first place
    isGameOver = False

    isPlayerWhite  = True  # If a human is playing white then it is True, if an AI is playing then this is False
    isPlayerBlack = False  # Same as above but for black

    while isGameRunning:
        is_human_turn = (gs.whiteToMove and isPlayerWhite ) or (not gs.whiteToMove and isPlayerBlack)  # Conditions for the turn to be from a human

        for event in pg.event.get():
            if event.type == pg.QUIT:
                isGameRunning = False

            elif event.type == pg.MOUSEBUTTONDOWN:
                if not isGameOver and is_human_turn:  # only allow mouse clicks if the game has not finished and, it's the human's turn
                    location = pg.mouse.get_pos()  # This gets the x and y coordinates of the mouse
                    col = location[0] // squareSize  # columns are the x coordinates
                    row = location[1] // squareSize  # rows are the y coordinates

                    if sqSelected == (row, col) or col >= 8:  # Checks to see if the user clicks the same square twice or if the user clicked the move log
                        sqSelected = ()  # Undoes the sqSelected
                        playerMoveClicks = []  # Clears player clicks
                    else:
                        sqSelected = (row, col)
                        playerMoveClicks.append(sqSelected)  # sqSelected clicks get appended to the player clicks (First click and second click)
                        print(playerMoveClicks)

                    if len(playerMoveClicks) == 2:  # Checks for if the second click has been made
                        move = ChessEngine.Move(playerMoveClicks[0], playerMoveClicks[1], gs.board)
                        print(move.get_move_in_chess_notation())
                        for i in range(len(legalMoves)):
                            if move == legalMoves[i]:
                                gs.make_move(legalMoves[i])
                                # The only moves able to be made are the moves generated by the engine
                                isMoveMade = True
                                animate = True
                                sqSelected = ()  # Resets the user clicks so the user can make another move
                                playerMoveClicks = []
                                break

                        if not isMoveMade:
                            playerMoveClicks = [sqSelected]

            elif event.type == pg.KEYDOWN:
                if event.key == pg.K_z:  # Undoes the move when z is pressed
                    gs.undo_move()
                    sqSelected = ()
                    playerMoveClicks = []
                    isMoveMade = True
                    animate = False
                    isGameOver = False

                if event.key == pg.K_r:  # Resets the board when r is pressed
                    gs = ChessEngine.GameState()
                    legalMoves = gs.get_valid_moves()
                    sqSelected = ()
                    playerMoveClicks = []
                    isMoveMade = False
                    animate = False
                    isGameOver = False

        # AI move logic (moved inside main game loop)
        if not isGameOver and not is_human_turn:
            AIMove = ChessAI.get_best_move(gs,legalMoves)
            if AIMove is None:
                AIMove = ChessAI.choose_random_move(legalMoves)
            gs.make_move(AIMove)
            isMoveMade = True
            animate = True

        if isMoveMade:
            if animate:
                animate_piece_move(gs.moveLog[-1], screen, gs.board, clock)
            legalMoves = gs.get_valid_moves()
            isMoveMade = False
            animate = False

        render_game_state(screen, gs, legalMoves, sqSelected, moveLogFont)

        if gs.checkmate or gs.stalemate:
            isGameOver = True
            if gs.stalemate:
                text = 'Stalemate!'
            else:
                if gs.whiteToMove:
                    text = 'Black Wins by Checkmate!'
                else:
                    text = 'White Wins by Checkmate!'
            display_game_over_message(screen, text)

        clock.tick(maxFrameRate)
        pg.display.flip()  # Updates the display

def render_game_state(screen_1, gs_1, valid_moves, sq_selected, move_log_font):
    draw_chessboard(screen_1)  # draws the squares on the board
    highlight_valid_moves(screen_1, gs_1, valid_moves, sq_selected)
    render_pieces(screen_1, gs_1.board)  # draws pieces on top of the board
    render_move_history(screen_1, gs_1, move_log_font)

'''
Draws the squares on the board
'''
def draw_chessboard(screen_1):
    colours = [pg.Color("white"), pg.Color("#BEE5B0")]
    for r in range(boardSize):
        for c in range(boardSize):
            colour = colours[((r + c) % 2)]
            pg.draw.rect(screen_1, colour, pg.Rect(c * squareSize, r * squareSize, squareSize, squareSize))

'''
Move highlighting - Highlights the piece selected and its possible moves
'''
def highlight_valid_moves(screen_1, gs_1, valid_moves, sq_selected):  # Added sq_selected parameter
    if sq_selected != ():  # Makes sure the user hasn't clicked on an end square yet
        r, c = sq_selected
        if gs_1.board[r][c][0] == ('w' if gs_1.whiteToMove else 'b'):
            # Makes sure that the square selected is a piece that can be moved
            # Highlighting the selected square
            s = pg.Surface((squareSize, squareSize))
            s.set_alpha(100)  # sets the transparency between 1 and 255
            s.fill(pg.Color('blue'))
            screen_1.blit(s, (c * squareSize, r * squareSize))

            # Highlighting possible moves
            s.fill(pg.Color('red'))
            for move_1 in valid_moves:  # Changed from validMoves to valid_moves
                if move_1.startRow == r and move_1.startCol == c:
                    # Checks if the move starts from the selected square
                    screen_1.blit(s, (move_1.endCol * squareSize, move_1.endRow * squareSize))

'''
Draws the pieces on the board
'''
def render_pieces(screen_1, board):
    for r in range(boardSize):
        for c in range(boardSize):
            piece = board[r][c]
            if piece != '--':
                screen_1.blit(Images[piece], pg.Rect(c * squareSize, r * squareSize, squareSize, squareSize))

'''
Draws the move log on the screen
'''
def render_move_history(screen_1, gs_1, font):
    move_log_rectangle = pg.Rect(screenWidth, 0, moveHistoryPanelWidth, moveHistoryPanelHeight)
    pg.draw.rect(screen_1, pg.Color('black'), move_log_rectangle)  # Colour of rectangle

    move_log = gs_1.moveLog
    move_texts = []
    for i in range(0, len(move_log), 2):  # Changed x to i
        move_string = str(i // 2 + 1) + '.' + str(move_log[i]) + ' '
        # Makes sure each move is under the same turn (move 1 and 2 is turn 1) (move 5 and 6 is turn 3)
        if i + 1 < len(move_log):  # Makes sure black made a move
            move_string += str(move_log[i + 1]) + ' '
        move_texts.append(move_string)

    moves_per_row = 3
    shift = 5
    texty = shift
    line_space = 2
    for i in range(0, len(move_texts), moves_per_row):  # Changed x to i
        # Makes sure multiple moves appear on the same line before going to the next line
        text_1 = ''
        for j in range(moves_per_row):
            if i + j < len(move_texts):
                text_1 += move_texts[i + j]
        text_object = font.render(text_1, True, pg.Color('White'))  # Colour of text
        text_location = move_log_rectangle.move(shift, texty)
        screen_1.blit(text_object, text_location)  # Changed screen to screen_1
        texty += text_object.get_height() + line_space


'''
Move animation
'''
frames_per_square = 10  # frames to move within a square
def animate_piece_move(move_1, screen_1, board, clock_1):  # Removed unused parameter
    frames_per_square = 10  # Moved inside the function to avoid global variable
    difference_in_row = move_1.endRow - move_1.startRow
    difference_in_col = move_1.endCol - move_1.startCol
    frame_count = (abs(difference_in_row) + abs(difference_in_col)) * frames_per_square  # Changed to use local variable

    colours = [pg.Color("white"), pg.Color("#BEE5B0")]  # Added colours definition inside the function
    for frame in range(frame_count + 1):
        r, c = (move_1.startRow + difference_in_row * frame / frame_count,
                move_1.startCol + difference_in_col * frame / frame_count)  # Forming a ratio of the frames

        draw_chessboard(screen_1)
        render_pieces(screen_1, board)  # Draws the state of the board

        # Need to erase the piece moved from its ending square
        colour = colours[(move_1.endRow + move_1.endCol) % 2]
        end_square = pg.Rect(move_1.endCol * squareSize, move_1.endRow * squareSize, squareSize, squareSize)
        pg.draw.rect(screen_1, colour,
                     end_square)  # Draws a rectangle of the correct square to erase the piece from the board

        # Draw the captured piece onto the rectangle
        if move_1.pieceCaptured != '--':
            if move_1.isEnpassantMove:  # Fixing previous bug where the captured piece would move to its 'captured position' when it should just stay in the same place
                enpassant_row = (move_1.endRow + 1) if move_1.pieceCaptured[0] == 'b' else move_1.endRow - 1
                end_square = pg.Rect(move_1.endCol * squareSize, enpassant_row * squareSize, squareSize, squareSize)
                screen_1.blit(Images[move_1.pieceCaptured], end_square)

        # Drawing the moving piece
        screen_1.blit(Images[move_1.pieceMoved], pg.Rect(c * squareSize, r * squareSize, squareSize, squareSize))
        pg.display.flip()
        clock_1.tick(60)


def display_game_over_message(screen_1, text_1):
    font = pg.font.SysFont('Helvetica', 40, True, True)
    text_object = font.render(text_1, 0, pg.Color('Gray'))
    text_location = pg.Rect(0, 0, screenWidth, screenHeight).move(
        screenWidth / 2 - text_object.get_width() / 2,
        screenHeight / 2 - text_object.get_height() / 2
    )
    screen_1.blit(text_object, text_location)
    text_object = font.render(text_1, 0, pg.Color('Black'))
    screen_1.blit(text_object, text_location.move(2, 2))


if __name__ == "__main__":
    main()
