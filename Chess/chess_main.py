"""
This is the main file. It is responsible for handling user input and
displaying the current Game State
"""

import pygame as p
from chess_engine import GameState, Move
from ai_backend import find_best_move, find_random_move


# Setting up the size of the screen
board_w = board_h = 512
move_log_panel_width = 350
move_log_panel_height = board_h
# Chess Boards are 8x8
dim = 8
# Creating the dimensions of each square as fraction of the screen size
sq_size = board_h // dim
# For animations
max_fps = 20
# Load all images at once
img = {}
# Should only animate when a move is being made not when it is being undone
animate = False


# Load each image once in the main file.
def load_images():
    pieces = ["wp", "wR", "wN", "wB", "wK", "wQ", "bp", "bR", "bN", "bB", "bK", "bQ"]
    for piece in pieces:
        img[piece] = p.transform.scale(
            p.image.load("images/" + piece + ".png"), (sq_size, sq_size)
        )


"""
This function is responsible for drawing the board and initialising pygame
It will be in charge of displaying the screen, controlling the frame rate,
and loading images onto the screen.
"""


def main():
    p.init()
    screen = p.display.set_mode((board_w + move_log_panel_width, board_h))
    # Clock to control the frame rate
    clock = p.time.Clock()
    screen.fill(p.Color("White"))
    move_log_font = p.font.SysFont("Arial", 18, True, False)
    gs = GameState()
    # Load all the images
    load_images()
    programRunning = True
    """
    Initially no square is selected so the tuple will be empty
    sqSelected keeps track of the last click from the user
    """
    # Using tuple (row, col) here instead of referencing x, y coordinates
    sqSelected = ()
    # Keeps tracks of the player clicks consisting of two tuples [(3,2), (5,5)]
    playerClicks = []
    validMoves = gs.getValidMoves()
    # A new set of valid moves will only be generated if a valid move is made
    # in the first place
    moveMade = False
    gameOver = False
    # If a human is playing white then it is True
    # if an AI is playing then this is False
    playerOne = True
    # Same as above but for black
    playerTwo = False
    while programRunning:
        # Conditions for the turn to be from a human
        isHumanTurn = (gs.whiteToMove and playerOne) or (
            not gs.whiteToMove and playerTwo
        )
        for e in p.event.get():
            if e.type == p.QUIT:
                programRunning = False
            elif e.type == p.MOUSEBUTTONDOWN:
                # only allow mouse clicks if the game has not finished
                # and is the human's turn
                if not gameOver and isHumanTurn:
                    # This gets the x, y coordinates of the mouse click
                    location = p.mouse.get_pos()
                    # Columns are the x coordinates
                    col = location[0] // sq_size
                    # Rows are the y coordinates
                    row = location[1] // sq_size
                    # Checks to see if the user clicks the same square twice
                    # or if the user clicked the move log
                    if sqSelected == (row, col) or col >= 8:
                        # Undo the sqSelected
                        sqSelected = ()
                        # Clears player clicks
                        playerClicks = []
                    else:
                        sqSelected = (row, col)
                        # sqSelected clicks get appended to the player
                        # clicks (First click and second click)
                        playerClicks.append(sqSelected)
                    # Checks for if the second click has been made
                    if len(playerClicks) == 2:
                        move = Move(
                            playerClicks[0], playerClicks[1], gs.board
                        )
                        print(move.getChessNotation())
                        for i in range(len(validMoves)):
                            if move == validMoves[i]:
                                # The only moves able to be made are the
                                # moves generated by the engine
                                gs.makeMove(validMoves[i])
                                moveMade = True
                                animate = True
                                # Resets the user clicks so the
                                # user can make another move
                                sqSelected = ()
                                playerClicks = []
                        if not moveMade:
                            playerClicks = [sqSelected]
            elif e.type == p.KEYDOWN:
                # Undo the move when z is pressed
                if e.key == p.K_z:
                    gs.undoMove()
                    sqSelected = ()
                    playerClicks = []
                    moveMade = True
                    animate = False
                    gameOver = False
                # Reset the board when r is pressed
                if e.key == p.K_r:
                    gs = GameState()
                    validMoves = gs.getValidMoves()
                    sqSelected = ()
                    playerClicks = []
                    moveMade = False
                    animate = False
                    gameOver = False
        # AI move logic
        if not gameOver and not isHumanTurn:
            AIMove = find_best_move(gs, validMoves)
            if AIMove is None:
                AIMove = find_random_move(validMoves)
            gs.makeMove(AIMove)
            moveMade = True
            animate = True

        if moveMade:
            if animate:
                animate_move(gs.moveLog[-1], screen, gs.board, clock)
            validMoves = gs.getValidMoves()
            moveMade = False
            animate = False

        draw_game_state(screen, gs, validMoves, sqSelected, move_log_font)

        if gs.checkmate or gs.stalemate:
            gameOver = True
            draw_game_end_txt(
                screen,
                (
                    "Stalemate"
                    if gs.stalemate
                    else (
                        "Black wins by Checkmate"
                        if gs.whiteToMove
                        else "White wins by Checkmate"
                    )
                ),
            )

        clock.tick(max_fps)
        p.display.flip()


"""
This function is responsible for drawing the squares and the pieces
onto the board
"""


def draw_game_state(screen, gs, validMoves, sqSelected, move_log_font):
    # Draw the squares on the board
    draw_board(screen)
    highlight_squares(screen, gs, validMoves, sqSelected)
    # Draw pieces on top of the board
    draw_pieces(screen, gs.board)
    draw_move_log(screen, gs, move_log_font)


"""
This function is responsible for drawing the squares on the board
"""


def draw_board(screen):
    global Colors
    Colors = [p.Color("white"), p.Color("#BEE5B0")]
    for r in range(dim):
        for c in range(dim):
            color = Colors[((r + c) % 2)]
            p.draw.rect(
                screen, color,
                p.Rect(c * sq_size, r * sq_size, sq_size, sq_size)
            )


"""
Highlights the piece selected and its possible moves
"""


def highlight_squares(screen, gs, validMoves, sqSelected):
    # Makes sure the user hasn't clicked on an end square yet
    if sqSelected != ():
        r, c = sqSelected
        # Make sure that the square selected is a piece that can be moved
        if gs.board[r][c][0] == ("w" if gs.whiteToMove else "b"):
            # Highlighting the selected square
            s = p.Surface((sq_size, sq_size))
            s.set_alpha(100)  # sets the transparency between 1 and 255
            s.fill(p.Color("blue"))
            screen.blit(s, (c * sq_size, r * sq_size))
            # Highlighting possible moves
            s.fill(p.Color("red"))
            for move in validMoves:
                if move.startRow == r and move.startCol == c:
                    # Checks if the move starts from the selected square
                    screen.blit(
                        s, (move.endCol * sq_size, move.endRow * sq_size))


"""
This function is responsible for drawing the pieces on the board
"""


def draw_pieces(screen, board):
    for r in range(dim):
        for c in range(dim):
            piece = board[r][c]
            if piece != "--":
                screen.blit(
                    img[piece],
                    p.Rect(c * sq_size, r * sq_size, sq_size, sq_size)
                )


"""
Draws the move log
"""


def draw_move_log(screen, gs, font):
    move_log_rect = p.Rect(
        board_w, 0, move_log_panel_width, move_log_panel_height)
    # Colour of rectangle
    p.draw.rect(screen, p.Color("black"), move_log_rect)
    moveLog = gs.moveLog
    moveTexts = []
    for i in range(0, len(moveLog), 2):
        moveString = str(i // 2 + 1) + "." + str(moveLog[i]) + " "
        # Makes sure each move is under the same turn
        # (move 1 and 2 is turn 1) (move 5 and 6 is turn 3)
        # Makes sure black made a move
        if i + 1 < len(moveLog):
            moveString += str(moveLog[i + 1]) + " "
        moveTexts.append(moveString)
    movesPerRow = 3
    shift = 5
    textY = shift
    lineSpace = 2
    # Makes sure multiple moves appear on the same line before going to
    # the next move
    for i in range(0, len(moveTexts), movesPerRow):
        text = ""
        for j in range(movesPerRow):
            if i + j < len(moveTexts):
                text += moveTexts[i + j]
        # Colour of text
        textObject = font.render(text, True, p.Color("White"))
        textLocation = move_log_rect.move(shift, textY)
        screen.blit(textObject, textLocation)
        textY += textObject.get_height() + lineSpace


"""
This function is responsible for animating the move
"""


def animate_move(move, screen, board, clock):
    global Colors
    diff_in_row = move.endRow - move.startRow
    differenceInCol = move.endCol - move.startCol
    # frames to move within a square
    framesPerSquare = 10
    frameCount = (abs(diff_in_row) + abs(differenceInCol)) * framesPerSquare
    for frame in range(frameCount + 1):
        r, c = (
            move.startRow + diff_in_row * frame / frameCount,
            move.startCol + differenceInCol * frame / frameCount,
        )
        draw_board(screen)
        draw_pieces(screen, board)
        # Erase the piece moved from its ending square
        color = Colors[(move.endRow + move.endCol) % 2]
        endSquare = p.Rect(
            move.endCol * sq_size, move.endRow * sq_size, sq_size, sq_size
        )
        p.draw.rect(screen, color, endSquare)
        # Draw the captured piece onto the rectangle
        if move.pieceCaptured != "--":
            # Fixing previous bug where the captured piece would move
            # to its 'captured position' when it should just stay in
            # the same place
            if move.isEnpassantMove:
                enpassantRow = (
                    (move.endRow + 1)
                    if move.pieceCaptured[0] == "b"
                    else move.endRow - 1
                )
                endSquare = p.Rect(
                    move.endCol * sq_size, enpassantRow * sq_size, sq_size, sq_size
                )
            screen.blit(img[move.pieceCaptured], endSquare)
        # Draw the moving piece
        screen.blit(
            img[move.pieceMoved], p.Rect(c * sq_size, r * sq_size, sq_size, sq_size)
        )
        p.display.flip()
        clock.tick(60)


def draw_game_end_txt(screen, text):
    font = p.font.SysFont("Helvetica", 40, True, True)
    textObject = font.render(text, 0, p.Color("Gray"))
    textLocation = p.Rect(0, 0, board_w, board_h).move(
        board_w / 2 - textObject.get_width() / 2,
        board_h / 2 - textObject.get_height() / 2,
    )
    screen.blit(textObject, textLocation)
    textObject = font.render(text, 0, p.Color("Black"))
    screen.blit(textObject, textLocation.move(2, 2))


if __name__ == "__main__":
    main()
